/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./regex.ts#1649257948830
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});

(exports.buildPatternInternal = void 0);
var _immStack = _interopRequireDefault(require("@iter-tools/imm-stack"));
var _types = require("./types");
var _captures = require("./captures");
var _ast = require("./ast");
var _literals = require("./literals");
var _rbt = require("./rbt");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const identity = (next) => next;

const compose = (lExp, rExp) => {
  return (next) => lExp(rExp(next));
};

const growResult = (state, chr) => {
  state.result += chr;
};

const term = (global, capturesLen) => ({
  type: _types.contType,
  width: 0,
  name: 'term',
  next: null,

  match: (state) => {
    const { captureList } = state;
    const rootCapture = captureList.value;
    return rootCapture.result !== null
      ? {
          type: _types.successType,
          global,
          captures: (0, _captures.flattenCapture)(rootCapture, capturesLen),
        }
      : null;
  }
});

const unmatched = () => (next) => {
  return {
    type: _types.contType,
    width: 1,
    name: 'unmatched',
    next,
    match: () => next,
  };
};

// match a character
const literal =
  (value, test, negate = false) => (next) => {
    return {
      type: _types.contType,
      width: 1,
      name: 'literal',
      next,
      match: (state, chr, chrCode) => {
        if (negate !== test(chrCode)) {
          growResult(state, chr);
          return next;
        } else {
          return null;
        }
      },
      value,
    };
  };

const expression =
  matchers => (next) => {
    const boundMatchers = matchers.map((matcher) => matcher(next));
    const result = { type: _types.exprType, seqs: boundMatchers };

    return {
      type: _types.contType,
      width: 0,
      name: 'expression',
      next,
      match: () => result,
      matchers: boundMatchers,
    };
  };

const resetRepetitionStates =
  (idxs, initialRepetitionStates) => (next) => {
    return {
      type: _types.contType,
      name: 'resetRepetitionStates',
      width: 0,
      next,
      match: (state) => {
        let { repetitionStates } = state;
        for (const idx of idxs) {
          repetitionStates = repetitionStates.find(idx).update(initialRepetitionStates[idx]);
        }

        state.repetitionStates = repetitionStates;

        return next;
      },
    };
  };

const edgeAssertion =
  (kind, flags) => (next) => {
    return {
      type: _types.contType,
      name: 'edgeAssertion',
      width: 0,
      next,
      match: flags.multiline
        ? kind === 'start'
          ? (state, context) => {
              const { lastCode } = context;
              return lastCode === null || !(0, _literals.testNotNewline)(lastCode) ? next : null;
            }
          : (state, context) => {
              const { nextCode } = context;
              return nextCode === null || !(0, _literals.testNotNewline)(nextCode) ? next : null;
            }
        : kind === 'start'
        ? (state, context) => {
            const { lastCode } = context;
            return lastCode === null ? next : null;
          }
        : (state, context) => {
            const { nextCode } = context;
            return nextCode === null ? next : null;
          },
      kind,
    };
  };

const boundaryAssertion = () => (next) => {
  return {
    type: _types.contType,
    name: 'boundaryAssertion',
    width: 0,
    next,
    match: (state, context) => {
      const { lastCode, nextCode } = context;
      const lastIsWord = lastCode === null ? false : (0, _literals.testWord)(lastCode);
      const nextIsWord = nextCode === null ? false : (0, _literals.testWord)(nextCode);
      return lastIsWord !== nextIsWord ? next : null;
    },
  };
};

const repeat =
  (exp, key, greedy = true) => (next) => {
    const matcher = {
      type: _types.contType,
      name: 'repeat',
      width: 0,
      next,

      match: (state, context) => {
        const repStateNode = state.repetitionStates.find(key);
        const { min, max } = repStateNode.value;

        if (context.seenRepetitions[key]) {
          return null;
        } else if (max === 0) {
          return next;
        } else {
          context.seenRepetitions[key] = true;
          const nextRepState = {
            min: min === 0 ? 0 : min - 1,
            max: max === 0 ? 0 : max - 1,
            context,
          };
          state.repetitionStates = repStateNode.update(nextRepState);

          return min > 0 ? repeatCont : exprCont;
        }
      }
    };

    const repeatCont = exp(matcher);
    const exprCont = {
      type: _types.exprType,
      seqs: greedy ? [repeatCont, next] : [next, repeatCont],
    };

    matcher.repeatCont = repeatCont;
    matcher.exprCont = exprCont;

    return matcher;
  };

const startCapture =
  idx => (next) => {
    return {
      type: _types.contType,
      width: 0,
      name: 'startCapture',
      next,
      match: (state) => {
        const { result, captureStack, captureList: parentList } = state;

        const list = _immStack.default;

        const capture = {
          idx,
          start: result === null ? 0 : result.length,
          end: null,
          result: null,
          parentList,
          children: list,
        };

        state.result = result === null ? '' : result;
        state.captureStack = captureStack.push(capture);
        state.captureList = list;

        return next;
      },
      idx,
    };
  };

const endCapture = () => (next) => {
  return {
    type: _types.contType,
    width: 0,
    name: 'endCapture',
    next,
    match: (state) => {
      const { result, captureStack, captureList: children } = state;
      const { start, parentList, idx } = captureStack.value;
      const end = result.length;

      const capture = {
        idx,
        start: result === null ? 0 : result.length,
        end,
        result: result.slice(start, end),
        parentList,
        children,
      };

      let list = parentList;

      if (list.size > 0 && list.value.idx === capture.idx) {
        // Subsequent matches of the same capture group overwrite
        list = list.prev;
      }

      if (captureStack.prev.size === 0) state.result = null;
      state.captureStack = captureStack.prev;
      state.captureList = list.push(capture);

      return next;
    },
  };
};

const capture = (idx, exp) => {
  return compose(startCapture(idx), compose(exp, endCapture()));
};

const visitExpression = (
  alternatives,
  state,
  visit,
) => {
  const qIdxs = (state.qIdxs = []);

  const reset = resetRepetitionStates(qIdxs, state.initialRepetitionStates);

  // prettier-ignore
  switch (alternatives.length) {
    case 0: return identity;
    case 1: return compose(reset, visit(alternatives[0]));
    default: return expression(alternatives.map(alt => compose(reset, visit(alt))));
  }
};

const visitors = {
  Backreference: () => {
    throw new Error('Regex backreferences not implemented');
  },

  Assertion: (node, state) => {
    if (node.kind === 'lookahead') {
      throw new Error('Regex lookahead not implemented');
    } else if (node.kind === 'lookbehind') {
      throw new Error('Regex lookbehind unsupported');
    } else if (node.kind === 'word') {
      return boundaryAssertion();
    } else {
      return edgeAssertion(node.kind, state.flags);
    }
  },

  Alternative: (node, state, visit) => {
    return node.elements.map(visit).reduce(compose, identity);
  },

  Group: (node, state, visit) => {
    return visitExpression(node.alternatives, state, visit);
  },

  CapturingGroup: (node, state, visit) => {
    if (typeof node.name === 'string') {
      throw new Error('Regex named capturing groups not implemented');
    }
    return capture(++state.cIdx, visitExpression(node.alternatives, state, visit));
  },

  Pattern: (node, state, visit) => {
    const qIdx = ++state.qIdx;
    state.initialRepetitionStates[qIdx] = { min: 0, max: Infinity };

    return compose(
      state.flags.sticky || (!state.flags.multiline && (0, _ast.isAnchored)(node))
        ? identity
        : // Allow the expression to seek forwards through the input for a match
          repeat(unmatched(), qIdx, false),
      // Evaluate pattern capturing to group 0
      capture(++state.cIdx, visitExpression(node.alternatives, state, visit))
    );
  },

  Character: (node) => {
    return literal(node.raw, (c) => c === node.value);
  },

  CharacterClass: (node, state) => {
    const tester = (0, _literals.getTester)(node, state.flags);

    return literal(node.raw, tester, node.negate);
  },

  CharacterSet: (node, state) => {
    const tester = (0, _literals.getTester)(node, state.flags);
    const name = (0, _ast.getCharSetDesc)(node);
    if (node.kind === 'any') {
      // I need to push negate back into the testers?
      return literal(name, tester);
    } else {
      return literal(node.negate ? name.toUpperCase() : name, tester, node.negate);
    }
  },

  Quantifier: (node, state, visit) => {
    const { element, min, max, greedy } = node;
    // See https://github.com/mysticatea/regexpp/issues/21
    if (min > max) {
      throw new Error('numbers out of order in {} quantifier');
    }
    const qIdx = ++state.qIdx;
    state.qIdxs.push(qIdx);

    state.initialRepetitionStates[qIdx] = { min, max };
    return repeat(visit(element), qIdx, greedy);
  },
};

const buildPatternInternal = (ast, flags) => {
  const pState = {
    cIdx: -1, // capture index
    qIdx: -1, // quantifier index
    flags,
    qIdxs: [],
    initialRepetitionStates: [],
  };

  if (pState.flags.unicode) {
    throw new Error('Regex u flag is unsupported');
  }

  const seq = (0, _ast.visit)(ast, pState, visitors);

  const initialState = {
    result: null,
    captureStack: _immStack.default,
    captureList: _immStack.default,
    repetitionStates: pState.initialRepetitionStates.reduce(
      (tree, state, i) => tree.insert(i, state),
      (0, _rbt.createTree)((a, b) => a - b)
    ),
  };

  // Bind `next` arguments. The final `next` value is the terminal state.
  const matcher = seq(term(pState.flags.global, pState.cIdx + 1));

  return { initialState, matcher };
};

exports.buildPatternInternal = buildPatternInternal;
