/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./engine.ts#1653621704382
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});

(exports.Sequence = (exports.Node = (exports.Match = (exports.Engine = void 0))));
var _literals = require("./literals");
var _types = require("./types");
var _pattern = require("../pattern");

const cloneMatcherState = (state) => {
  const { result, captureStack, repetitionStates } = state;
  return { result, captureStack, repetitionStates };
};

class Node {
  constructor() {
    this.worse = null;
  }
}

exports.Node = Node;

class Sequence extends Node {
  constructor(next, mutableState) {
    super();
    this.next = next;
    this.mutableState = mutableState;
  }
}

exports.Sequence = Sequence;

class Match extends Node {
  constructor(pattern, globalIdx, captures = null) {
    super();
    this.pattern = pattern;
    this.globalIdx = globalIdx;
    this.head = new Node();
    this.captures = captures;

    if (pattern.global || globalIdx === 0) {
      const { initialState, matcher } = (0, _pattern.getPatternInternal)(pattern);

      this.head.worse = new Sequence(matcher, cloneMatcherState(initialState));
    }
  }
}

exports.Match = Match;

class Engine {
  index = 0;
  starved = true;
  context0 = {
    width: 0,
    lastChr: undefined,
    lastCode: -1,
    nextChr: undefined,
    nextCode: -1,
    seenRepetitions: [],
  };
  context1 = {
    width: 1,
    chr: undefined,
    chrCode: -1,
  };
  context = this.context0;
  prevNode = null;
  node = null;
  /* eslint-enable lines-between-class-members */

  constructor(pattern) {
    this.global = pattern.global;
    this.repetitionCount = (0, _pattern.getPatternInternal)(pattern).initialState.repetitionStates.length;

    this.root = new Match(pattern, 0);
    this.match = this.root;
  }

  get done() {
    return this.root.head.worse === null;
  }

  feed(chr) {
    const { context0: ctx0, context1: ctx1 } = this;

    ctx0.lastChr = ctx0.nextChr;
    ctx0.lastCode = ctx0.nextCode;
    ctx0.nextChr = chr;
    ctx0.nextCode = chr === null ? -1 : (0, _literals.code)(chr);
    ctx0.seenRepetitions = new Array(this.repetitionCount);

    if (ctx0.lastChr !== undefined) {
      this.starved = false;
    }

    if (ctx0.nextChr !== null) {
      ctx1.chr = ctx0.nextChr;
      ctx1.chrCode = ctx0.nextCode;
    }
  }

  startTraversal(match) {
    const { head } = match;
    this.prevNode = head;
    this.node = head.worse;
    this.match = match;
  }

  fail() {
    if (!(this.node instanceof Sequence)) throw new Error();

    this.prevNode.worse = this.node = this.node.worse;
  }

  succeed(captures) {
    const { node, match } = this;
    if (!(node instanceof Sequence)) throw new Error();
    const { pattern, globalIdx } = match;

    // Stop matching any worse alternatives
    this.prevNode.worse = this.node = new Match(pattern, globalIdx + 1, captures);
  }

  explode(matchers) {
    const { node } = this;
    if (!(node instanceof Sequence)) throw new Error();

    const { mutableState, worse } = node;

    let prev = this.prevNode;
    let seq = undefined;
    for (const matcher of matchers) {
      seq = new Sequence(matcher, cloneMatcherState(mutableState));
      prev.worse = seq;
      prev = seq;
    }

    seq.worse = worse;

    // continue from the first of the nodes we just inserted
    this.node = this.prevNode.worse;
  }

  apply(state) {
    if (!(this.node instanceof Sequence)) throw new Error();

    if (state === null) {
      this.fail();
    } else if (state.type === _types.successType) {
      this.succeed(state.captures);
    } else if (state.type === _types.exprType) {
      this.explode(state.seqs);
    } else if (state.type === _types.contType) {
      this.node.next = state;
    } else {
      throw new Error(`Unexpected state of {type: '${(state).type}'}`);
    }
  }

  step0() {
    const context = this.context;

    let { node } = this;
    while (node instanceof Sequence && node.next.width === 0) {
      this.apply(node.next.match(node.mutableState, context));
      ({ node } = this);
    }
    if (node instanceof Sequence && node.next.width === 1 && context.nextChr === null) {
      this.fail();
    }
  }

  step1() {
    const context = this.context;
    if (this.node instanceof Sequence) {
      const { next, mutableState } = this.node;
      if (next.width === 1) {
        this.apply(next.match(mutableState, context));
      } else {
        throw new Error('w0 where w1 expected');
      }
    }
  }

  traverse(step) {
    this.startTraversal(this.root);

    while (true) {
      while (this.node !== null) {
        const { node } = this;
        step();
        if (node === this.node) {
          this.prevNode = this.node;
          this.node = this.node.worse;
        }
      }
      const last = this.prevNode;
      if (last instanceof Match && last.head.worse !== null) {
        this.startTraversal(last);
      } else {
        break;
      }
    }
  }

  traverse0() {
    const { starved } = this;

    if (starved) {
      throw new Error('step0 called without feeding new input');
    }

    this.context = this.context0;

    this.traverse(() => this.step0());

    const matches = [];

    let match = this.root;
    while (true) {
      if (match.captures !== null) {
        matches.push(match.captures);
        match.captures = null;
      }
      if (match.head.worse instanceof Match) {
        match = match.head.worse;
      } else {
        break;
      }
    }
    this.root = match;

    return matches;
  }

  traverse1() {
    this.context = this.context1;

    this.traverse(() => this.step1());

    this.starved = true;
  }
}

exports.Engine = Engine;
