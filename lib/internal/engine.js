/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./engine.ts#1653677836787
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});

(exports.Sequence = (exports.Node = (exports.Match = (exports.Failure = (exports.Engine = void 0)))));
var _literals = require("./literals");
var _types = require("./types");
var _pattern = require("../pattern");

const cloneMatcherState = (state) => {
  const { result, captureStack, repetitionStates } = state;
  return { result, captureStack, repetitionStates };
};

class Node {
  constructor(data = null) {
    this.worse = null;
    this.data = data;
  }
}

exports.Node = Node;

class Sequence {
  constructor(next, mutableState) {
    this.next = next;
    this.mutableState = mutableState;
  }
}

exports.Sequence = Sequence;

class Match {
  constructor(pattern, globalIdx, captures = null) {

    this.pattern = pattern;
    this.globalIdx = globalIdx;
    // Ensures prevNode is always defined so we can replace using `prevNode.worse = ...`
    this.head = null;
    this.captures = captures;

    if (pattern.global || globalIdx === 0) {
      const head = new Node();
      const fail = new Node(new Failure());

      head.worse = fail;

      const { initialState, matcher } = (0, _pattern.getPatternInternal)(pattern);

      const seq = new Node(new Sequence(matcher, cloneMatcherState(initialState)));
      seq.worse = fail;
      head.worse = seq;

      this.head = head;
    }
  }
}

exports.Match = Match;
class Failure {}
exports.Failure = Failure;

const isSequence = r => r.constructor === Sequence;
const isMatch = r => r.constructor === Match;
const isFailure = r => r.constructor === Failure;

const context0Initial = {
  width: 0,
  lastChr: undefined,
  lastCode: -1,
  nextChr: undefined,
  nextCode: -1,
  seenRepetitions: undefined,
};
const context1Initial = {
  width: 1,
  chr: undefined,
  chrCode: -1,
};

class Engine {
  index = 0;
  starved = true;
  context0 = {...context0Initial};
  context1 = {...context1Initial};
  context = this.context0;
  prevNode = null;
  node = null;

  constructor(pattern) {
    this.global = pattern.global;
    this.repetitionCount = (0, _pattern.getPatternInternal)(pattern).initialState.repetitionStates.length;

    this.root = new Match(pattern, 0);
    this.match = this.root;
  }

  get done() {
    return this.root.head === null;
  }

  feed(chr) {
    const { context0: ctx0, context1: ctx1 } = this;

    ctx0.lastChr = ctx0.nextChr;
    ctx0.lastCode = ctx0.nextCode;
    ctx0.nextChr = chr;
    ctx0.nextCode = chr === null ? -1 : (0, _literals.code)(chr);
    ctx0.seenRepetitions = new Array(this.repetitionCount);

    if (ctx0.lastChr !== undefined) {
      this.starved = false;
    }

    if (ctx0.nextChr !== null) {
      ctx1.chr = ctx0.nextChr;
      ctx1.chrCode = ctx0.nextCode;
    }
  }

  startTraversal(match) {
    if (match.head === null) throw new Error();
    const { head } = match;
    this.prevNode = head;
    this.node = head.worse;
    this.match = match;
  }

  fail() {
    const { node } = this;
    if (!isSequence(node.data)) throw new Error();

    this.prevNode.worse = this.node = node.worse;
  }

  succeed(captures) {
    const { node, match } = this;
    if (!isSequence(node.data)) throw new Error();
    const { pattern, globalIdx } = match;

    // Stop matching any worse alternatives
    this.prevNode.worse = this.node = new Node(new Match(pattern, globalIdx + 1, captures));
  }

  explode(matchers) {
    const { node } = this;
    if (!isSequence(node.data)) throw new Error();

    const { worse } = node;
    const { mutableState } = node.data;

    let prev = this.prevNode;
    let seq = undefined;
    for (const matcher of matchers) {
      seq = new Node(new Sequence(matcher, cloneMatcherState(mutableState)));
      prev.worse = seq;
      prev = seq;
    }

    seq.worse = worse;

    // continue from the first of the nodes we just inserted
    this.node = this.prevNode.worse;
  }

  apply(state) {
    const { node } = this;
    if (!isSequence(node.data)) throw new Error();

    if (state.type === _types.failureType) {
      this.fail();
    } else if (state.type === _types.successType) {
      this.succeed(state.captures);
    } else if (state.type === _types.exprType) {
      this.explode(state.seqs);
    } else if (state.type === _types.contType) {
      node.data.next = state;
    } else {
      throw new Error(`Unexpected state of {type: '${(state).type}'}`);
    }
  }

  step0() {
    const context = this.context;

    let { data } = this.node;
    while (isSequence(data) && data.next.width === 0) {
      this.apply(data.next.match(data.mutableState, context));
      ({ data } = this.node);
    }
  }

  step1() {
    const { node } = this;
    const context = this.context;
    const { next, mutableState } = node.data;
    if (next.width === 1) {
      this.apply(next.match(mutableState, context));
    } else {
      throw new Error('w0 where w1 expected');
    }
  }

  traverse(step) {
    this.startTraversal(this.root);

    let { node } = this;
    while (true) {
      while (isSequence(node.data)) {
        const prevNode = node;
        step();
        ({ node } = this);
        if (prevNode === node) {
          this.prevNode = node;
          this.node = node = node.worse;
        }
      }

      if (isMatch(node.data) && node.data.head !== null) {
        this.startTraversal(node.data);
        ({ node } = this);
      } else {
        break;
      }
    }
  }

  traverse0() {
    const { starved } = this;

    if (starved) {
      throw new Error('step0 called without feeding new input');
    }

    this.traverse(this.step0.bind(this));


    if (this.context0.nextChr === null) {
      this.traverse(this.fail.bind(this));
    }

    const matches = [];

    let match = this.root;
    while (true) {
      if (match.captures !== null) {
        matches.push(match.captures);
        match.captures = null;
      }
      if (match.head !== null && isMatch(match.head.worse.data)) {
        match = match.head.worse.data;
      } else {
        break;
      }
    }

    this.root = match;
    this.context = this.context1;

    return matches;
  }

  traverse1() {

    this.traverse(this.step1.bind(this));

    this.context = this.context0;
    this.starved = true;
  }
}

exports.Engine = Engine;
