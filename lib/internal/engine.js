/* @macrome
 * @generatedby @macrome/generator-typescript
 * @generatedfrom ./engine.ts#1653254319074
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
"use strict";
Object.defineProperty(exports, "__esModule", {
  value: true
});

(exports.Sequence = (exports.Node = (exports.Match = (exports.Expression = (exports.Engine = void 0)))));
var _literals = require("./literals");
var _types = require("./types");
var _pattern = require("../pattern");

const cloneSequenceState = (state) => {
  const { result, parentCaptures, capture, repetitionStates } = state;
  return { result, parentCaptures, capture, repetitionStates };
};

const noContext = {};
const noMatches = [];

const nextSeq = node => {
  let n = node;
  // This algorithm can be summarized as: (up* check down* over)+
  // The directions are in reference to the diagram above
  if (n !== null) {
    // prettier-ignore
    for (;;) {
      while (n instanceof Expression && n.best !== null) n = n.best; // up*
      if (n instanceof Sequence && n !== node) break; // check
      while (n.parent !== null && n.worse === null) n = n.parent; // down*
      if (n.worse !== null) n = n.worse; // over
      else break;
    }
  }

  return n instanceof Match ? null : (n);
};

const getSeq = node => {
  return node instanceof Sequence ? node : nextSeq(node);
};

class Node {
  constructor(parent) {
    this.parent = parent;
    this.better = null;
    this.worse = null;
  }

  replaceWith(node) {
    const { worse, better, parent } = this;
    if (worse !== null) worse.better = node;
    if (better !== null) better.worse = node;
    if (parent !== null && parent.best === this) parent.best = node;
    node.parent = parent;
    node.better = better;
    node.worse = worse;
    return node;
  }

  remove() {
    const { worse, better, parent } = this;

    // better and worse will never both be null except at the root node
    // thus we will always have a next
    let sibling = null;

    if (better !== null) {
      better.worse = worse;
      sibling = better;
    } else {
      parent.best = worse;
    }
    if (worse !== null) {
      worse.better = better;
      sibling = worse;
    }

    if (sibling === null) {
      if (!(parent instanceof Match)) throw new Error('Unepxected singleton expression');
      parent.best = null;
    } else if (sibling.better === null && sibling.worse === null && !(parent instanceof Match)) {
      // make sure better and worse will (almost) never both be null!
      parent.replaceWith(sibling);
    }
  }

  removeWorse() {
    const { better, worse, parent } = this;
    if (worse !== null) worse.better = null;
    this.worse = null;

    if (better === null && !(parent instanceof Match)) {
      parent.replaceWith(this);
    }
    return this;
  }
}

exports.Node = Node;

class Sequence extends Node {
  constructor(parent, next, state) {
    super(parent);
    this.next = next;
    this.state = state;
  }

  fail() {
    const { worse, better, parent } = this;

    if (parent instanceof Match && better === null && worse === null) {
      parent.best = null;
      return getSeq(parent);
    } else {
      this.remove();

      if (this.worse !== null && this.worse instanceof Match) {
        this.worse.promote();
      }
      return nextSeq(this);
    }
  }

  succeed(captures) {
    const { parent } = this;
    const { engine, globalIdx } = parent.match;

    const match = new Match(this.parent, engine, engine.global ? globalIdx + 1 : -1, [captures]);

    if (engine.global) {
      match.buildSequences([engine.matcher], cloneSequenceState(engine.initialMatchState));
    }

    this.replaceWith(match);

    return getSeq(match.promote());
  }

  explode(seqs) {
    const { parent, better, worse } = this;
    if (better === null && worse === null && parent instanceof Match) {
      return getSeq(parent.buildSequences(seqs, this.state));
    } else {
      const expr = new Expression(parent).buildSequences(seqs, this.state);
      return getSeq(this.replaceWith(expr));
    }
  }

  apply(state) {
    if (state === null) {
      return this.fail();
    } else if (state.type === _types.successType) {
      return this.succeed(state.captures);
    } else if (state.type === _types.exprType) {
      return this.explode(state.seqs);
    } else if (state.type === _types.contType) {
      this.next = state;
      return this;
    } else {
      throw new Error(`Unexpected state of {type: '${(state).type}'}`);
    }
  }
}

exports.Sequence = Sequence;

function* childrenOf(expr) {
  let seq = expr.best;
  while (seq !== null) {
    yield seq;
    seq = seq.worse;
  }
}

class Expression extends Node {
  constructor(parent) {
    super(parent);
    this.match = this instanceof Match ? this : parent.match;
    this.best = null;
  }

  buildSequences(matchers, sequenceState) {
    const best = new Sequence(this, null, sequenceState);
    let prev = best;

    for (const matcher of matchers) {
      const seq = new Sequence(this, matcher, cloneSequenceState(sequenceState));
      seq.better = prev;
      prev.worse = seq;
      prev = seq;
    }

    if (best.worse === null) {
      throw new Error('Empty expressions are forbidden');
    }

    best.worse.better = null;

    this.best = best.worse;
    return this;
  }

  get children() {
    return childrenOf(this);
  }
}

exports.Expression = Expression;

class Match extends Expression {
  constructor(parent, engine, globalIdx, matches) {
    super(parent);
    this.engine = engine;
    this.globalIdx = globalIdx;
    this.matches = matches;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  replaceWith(node) {
    if (!(node instanceof Match)) throw new Error('Cannot replace match with non-match');
    this.matches.push(...node.matches);
    node.matches = this.matches;
    if (this.parent === null) {
      this.engine.root = node;
    }
    return super.replaceWith(node);
  }

  // Put this match in its correct position in the structure, eliminating any worse sequences
  promote() {
    let expr = this;
    // A single match may break out of multiple layers of nesting
    while (expr.better === null && (expr === this || !(expr instanceof Match))) {
      expr = expr.parent;
    }

    if (expr !== this && expr instanceof Match) {
      return expr.replaceWith(this);
    } else {
      expr.removeWorse();
      if (expr !== this) expr.replaceWith(this);
      return expr;
    }
  }
}

exports.Match = Match;

class Engine {
  constructor(pattern) {
    const { initialState, matcher } = (0, _pattern.getPatternInternal)(pattern);
    this.global = pattern.global;
    this.initialMatchState = initialState;
    this.repetitionCount = initialState.repetitionStates.length;
    this.matcher = matcher;

    this.root = new Match(null, this, pattern.global ? 0 : -1, []);
    this.root.buildSequences([matcher], initialState);

    this.index = 0;
    this.width = 0;
    this.lastChr = undefined;
    this.chr = undefined;
    this.starved = true;
  }

  get done() {
    return this.root.best === null;
  }

  feed(chr) {
    this.lastChr = this.chr;
    this.chr = chr;
    if (chr !== null) {
      this.index++;
    }
    if (this.lastChr !== undefined) {
      this.starved = false;
    }
  }

  step0() {
    const { lastChr, chr, starved } = this;

    if (starved) {
      throw new Error('step0 called without feeding new input');
    }

    const seenRepetitions = new Array(this.repetitionCount);
    const context = {
      lastChr,
      lastCode: lastChr === null ? null : (0, _literals.code)(lastChr),
      nextChr: chr,
      nextCode: chr === null ? null : (0, _literals.code)(chr),
      seenRepetitions,
    };

    let seq = nextSeq(this.root);

    while (seq !== null) {
      const { next, state } = seq;

      if (next.width === 0) {
        // Match against any number of chained width 0 states
        seq = seq.apply(next.match(state, context));
      } else if (chr === null) {
        // the input ended before the pattern succeeded
        seq = seq.fail();
      } else {
        seq = nextSeq(seq);
      }
    }

    const { root } = this;
    const { matches } = root;

    if (chr === null) {
      root.best = null;
    } else {
      this.width = 1;
    }

    if (matches.length > 0) {
      root.matches = [];
      return matches;
    } else {
      return noMatches;
    }
  }

  step1() {
    const { chr } = this;
    let seq = nextSeq(this.root);

    if (chr === null) {
      throw new Error('step1 cannot be called on {chr: null}');
    }

    while (seq !== null) {
      const { next, state } = seq;

      if (next.width !== 1) {
        throw new Error('Unexpectedly ran step1 with width 0 matchers active');
      }

      const node = seq.apply(next.match(state, chr, (0, _literals.code)(chr), noContext));
      // Remove returns the nextSeq, so don't skip it
      seq = node === seq ? nextSeq(node) : node;
    }

    this.width = 0;
    this.starved = true;
  }
}

exports.Engine = Engine;
